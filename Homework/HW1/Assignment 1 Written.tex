\documentclass[12pt]{article}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage{hyperref}
\hypersetup{
    urlcolor=blue,
}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{chngpage}
\usepackage{soul,color}
\usepackage{graphicx,float,wrapfig}
\usepackage{ listings}
\usepackage{comment}
\usepackage{arabicfnt}

\newcommand{\Class}{ \normalsize CS 331: Algorithms and Complexity (Spring 2024)\\
\small    Unique Number: 50930, 50935 50940, 50945
}
%\newcommand{\ClassInstructor}{Fares}
% Homework Specific Information. Change it to your own
\newcommand{\Title}{Assignment 1}
\newcommand{\DueDate}{Thursday, 25 January, by 11.59pm}
\newcommand{\StudentName}{}
\newcommand{\StudentClass}{}
\newcommand{\StudentNumber}{}


\setlength\parindent{0pt}
% In case you need to adjust margins:
\topmargin=-0.45in      %
\evensidemargin=0in     %
\oddsidemargin=0in      %
\textwidth=6.5in        %
\textheight=9.0in       %
\headsep=0.25in         %

% Setup the header and footer
\pagestyle{fancy}                                                       %
\lhead{\StudentName}                                                 %
\chead{\Title}  %
\rhead{\firstxmark}                                                     %
\lfoot{\lastxmark}                                                      %
\cfoot{}                                                                %
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}}                          %
\renewcommand\headrulewidth{0.4pt}                                      %
\renewcommand\footrulewidth{0.4pt}                                      %

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Some tools
\newcommand{\enterProblemHeader}[1]{\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak%
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak}%
\newcommand{\exitProblemHeader}[1]{\nobreak\extramarks{#1 (continued)}{#1 continued on next page
\ldots}\nobreak%
\nobreak\extramarks{#1}{}\nobreak}%

\newcommand{\homeworkProblemName}{}%
\newcounter{homeworkProblemCounter}%
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]%
{\stepcounter{homeworkProblemCounter}%
\renewcommand{\homeworkProblemName}{#1}%
\section*{\homeworkProblemName}%
\enterProblemHeader{\homeworkProblemName}}%
{\exitProblemHeader{\homeworkProblemName}}%

\newcommand{\homeworkSectionName}{}%
\newlength{\homeworkSectionLabelLength}{}%
\newenvironment{homeworkSection}[1]%
{% We put this space here to make sure we're not connected to the above.

    \renewcommand{\homeworkSectionName}{#1}%
    \settowidth{\homeworkSectionLabelLength}{\homeworkSectionName}%
    \addtolength{\homeworkSectionLabelLength}{0.25in}%
    \changetext{}{-\homeworkSectionLabelLength}{}{}{}%
    \subsection*{\homeworkSectionName}%
    \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]}}%
    {\enterProblemHeader{\homeworkProblemName}%

    % We put the blank space above in order to make sure this margin
    % change doesn't happen too soon.
    \changetext{}{+\homeworkSectionLabelLength}{}{}{}}%

\newcommand{\Answer}{\ \\\textbf{Answer:} }
\newcommand{\Acknowledgement}[1]{\ \\{\bf Acknowledgement:} #1}


\def\changemargin#1#2{\list{}{\rightmargin#2\leftmargin#1}\item[]}
\let\endchangemargin=\endlist

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Make title
\title{\textmd{\bf \Class\\ \Title}\\\vspace{0.1in}\small{Due\ on\ \DueDate}}
\date{}
\author{\textbf{\StudentName}\ \ \StudentClass\ \ \StudentNumber}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
    \maketitle \thispagestyle{empty}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Begin edit from here

    \begin{homeworkProblem}
        \textbf{(a) (3 points)}\newline
        \textit{We need to find whether $\sqrt {n}$ or $\log(n^2)$ grows faster.\newline
        Solve: $\lim_{n\to\infty}\frac{\sqrt{n}}{\log(n^2)}$ =
            $\lim_{n\to\infty}\frac{d}{dn}\frac{\sqrt{n}}{\log(
            n^2)}$ = $\lim_{n\to\infty}\frac{1}{2\sqrt{n}} / \frac{2n}{n^2}$ (Constants don't
            matter), this approaches $\infty$ as n increases, $\therefore$}\newline
        \texttt{O(f$_4$(n)) = $\sqrt{n}$}\newline
        \texttt{O(f$_1$(n)) = n}\newline
        \texttt{O(f$_2$(n)) = n$\log\log$n}\newline
        \textit{Since $\log\log$n grows slower than n, then f$_2$(n) grows slower than
        f$_3$(n).}\newline
        \texttt{O(f$_3$(n)) = n$^2$}\newline
        \textit{By the growth rate diagram, polynomial functions grow slower than exponential
        functions.}\newline
        \texttt{O(f$_6$(n)) = $2^{\log n}$}\newline
        \textit{Since $\log n$ grows slower than $\sqrt{n}$, then f$_6$(n) grows slower than f$_5$
            (n).}\newline
        \texttt{O(f$_5$(n)) = $2^{\sqrt{n}}$}\newline
        \textit{$\therefore$ the order is:}
        \texttt{$f_{4}(n), f_{1}(n), f_{2}(n), f_{3}(n), f_{6}(n), f_{5}(n)$}\newline

        \textbf{(b) (3 points)}\newline
        \textit{Given a$_1$ = 1, a$_2$ = 8, and a$_n$ = a$_{n-1}$ + 2a$_{n-2}$ when n $\geq$ 3,
            show a$_n$ = 3 $\cdot$ 2$^{n-1}$ + 2(-1)$^{n}$ for all n $\in$ $\mathbb{N}$.}\newline
        \texttt{Define our predicate as P(n): a$_n$ = 3 $\cdot$ 2$^{n-1}$ + 2(-1)$^{n}$}\newline
        \textbf{Base Cases:}\newline
        \textit{We use two base cases since the recurrence relation is defined using the
        previous two terms.}\newline
        \begin{proof}
            P(1): Show a$_1$ = 3 $\cdot$ 2$^{1-1}$ + 2(-1)$^{1}$ = 1:
            \begin{tabular}{|lr|}
                \hline
                3 $\cdot$ 2$^{1-1}$ + 2(-1)$^{1}$ & Arithmetic \\
                = 3 $\cdot$ 2$^{0}$ + 2(-1)       & Simplify   \\
                = 3 $\cdot$ 1 + -2                & Simplify   \\
                = 1                               &            \\
                \hline
            \end{tabular}\newline
            $\therefore$ P(1) is true.\newline
            P(2): Show a$_2$ = 3 $\cdot$ 2$^{2-1}$ + 2(-1)$^{2}$ = 8:
            \begin{tabular}{|lr|}
                \hline
                3 $\cdot$ 2$^{2-1}$ + 2(-1)$^{2}$ & Arithmetic \\
                = 3 $\cdot$ 2$^{1}$ + 2(1)        & Simplify   \\
                = 3 $\cdot$ 2 + 2                 & Simplify   \\
                = 8                               &            \\
                \hline
            \end{tabular}\newline
            $\therefore$ P(2) is true.\newline
            $\therefore$, the base cases are true.
        \end{proof}

        \textbf{Inductive Hypothesis:}
        \textit{Assume for n = k, P(1), P(2), $\ldots$, P(k) are all true.}\newline

        \textbf{Inductive Step:}\newline
        \textit{Show P(k + 1), aka a$_{k+1}$ = 3 $\cdot$ 2$^{k}$ + 2(-1)$^{k+1}$.}
        \begin{proof}
            \begin{tabular}{|lr|}
                \hline
                a$_{k+1}$                                       & Definition           \\
                = a$_{k}$ + 2a$_{k-1}$                          & Inductive Hypothesis \\
                = (3 $\cdot$ 2$^{k-1}$ + 2(-1)$^{k}$) + 2(3 $\cdot$ 2$^{k-2}$ + 2(-1)$^{k-1}$) &
                Factor out 2 from first group \\
                = 2(3 $\cdot$ 2$^{k-2}$ + 2(-1)$^{
                    k-1}$) + 2(3 $\cdot$ 2$^{k-2}$ + 2(-1)$^{k-1}$) & Combine like terms   \\
                = 4(3 $\cdot$ 2$^{k-2}$ + 2(-1)$^{k-1}$)        & 4 = 2$^2$            \\
                = 2$^2$(3 $\cdot$ 2$^{k-2}$ + 2(-1)$^{k-1}$)    & Algebra              \\
                = 3 $\cdot$ 2$^{k}$ + 2(-1)$^{k+1}$             &                      \\
                \hline
            \end{tabular}\newline
            $\therefore$, we have shown that P(k + 1) is true, and by induction, P(n) is true for
            all n $\in$ $\mathbb{N}$.
        \end{proof}

        \textbf{(c)} \textbf{(4 points)}\newline
        \texttt{Algorithm 1(Alice)}
        \begin{proof}
            We need to swap the lines\newline
            \texttt{Report average as sum / count;}\newline
            \texttt{Increase count by 1;}\newline
            as in the first iteration, we will divide by 0, which is not the correct average.
        \end{proof}
        \texttt{Algorithm 2(Bob)}
        \begin{proof}
            Bob's algorithm is correct, shown using loop invariants.\newline
            Let S be the stream of integers indexed starting at 0.\newline
            \textbf{Inductive Hypothesis: }Assume at step k, \texttt{average}=avg of the first \texttt{count} elements where \texttt{count}=k.\newline
            \textbf{Initialization: }Before the first iteration, average=0 and count=0, which is
            correct, as there are no integers to calculate the average of.\newline
            \textbf{Maintenance: }Assume the inductive hypothesis is true at the beginning of the
            kth iteration.\newline
            $\therefore$, \texttt{average}=avg of the first \texttt{count} elements where \texttt{count}=k.\newline
            We read in integer $S_{k}$.\newline
            Next, we focus on the line \texttt{average = (average * count + S$_{k}$) / (count + 1)}.\newline
            Since \texttt{average}=$\frac{sum}{count}$, after multiplying by \texttt{count} and
            adding $S_{k}$, the expression yields the sum of the first k+1 elements.\newline
            Then, we divide by \texttt{count + 1} to get the average of the first k+1 elements.\newline
            $\therefore$, \texttt{average}=avg of the first \texttt{count+1} elements.\newline
            \texttt{count} is then incremented by one, which results in \texttt{count}=k+1.\newline
            $\therefore$, the induction hypothesis is true at the beginning of iteration n = k + 1
            .\newline
            \textbf{Termination: }The loop terminates when there are no more integers in the
            stream, in other words, when k=n, the length of the stream.\newline
            $\therefore$, \texttt{average}=avg of the first \texttt{count} elements where \texttt{count}=n, which is the average of all the integers in the stream.\newline
            $\therefore$, we have shown that the algorithm is correct.
        \end{proof}
    \end{homeworkProblem}

    \begin{homeworkProblem}
        \textbf{(6 points)}\newline
        \textit{For this problem, I would use a modified binary search, since I know that the
        array is sorted in ascending order with the target being less than the "max" values
        appended to the array.}
        \begin{verbatim}
// Finding bounds
int low = 0, high = 1;
while(E[high] < x) {
    low = high;
    high *= 2;
    if (high outOfBounds) {
        break;
    }
}
// Binary search
while (low <= high) {
    int mid = low + (high - low) / 2; // or (low + high) >>> 1
    if (mid outOfBounds) high = mid - 1;
    else if (E[mid] == x) return mid;
    else if (E[mid] < x) low = mid + 1;
    else high = mid - 1;
}
        \end{verbatim}
        \begin{proof}
            \textbf{Inductive Hypothesis: }Assume at step k, \texttt{low}($2^{k-1}$) is the lower
            bound of the search space and \texttt{high}($2^k$) is the upper bound of the search
            space where \texttt{x} is at index $\geq$ low.\newline
            \textbf{Initialization: }Before the first iteration, low=0 and high=1, and since all
            elements of E have index $\geq$ 0, then the inductive hypothesis is true.\newline
            The first while loop finds the bounds of the search space, which is O($\log n$) since
            we are exponentially increasing the search space.\newline
            \textbf{Maintenance: }Assume the inductive hypothesis is true at the beginning of the
            kth iteration.\newline
            if \texttt{E[high] < x}, then we double the search space while ignoring the current
            one, as we know that x is greater than the current high value.\newline
            We set \texttt{low} to \texttt{high} and \texttt{high} to \texttt{high} * 2, which
            means that \texttt{low} = $2^{k}$ and \texttt{high} = $2^{k+1}$.\newline
            Since the loop only ran because E[high$_{old}$] $<$ x, and \texttt{low} was set to
            \texttt{high}, then we know that E[low] $<$ x.\newline
            $\therefore$, \texttt{x} is at index $\geq$ low.\newline
            $\therefore$, the induction hypothesis is true at the beginning of iteration n = k +
            1.\newline
            \textbf{Termination: }The loop terminates when E[high] $\geq$ x, in other words, when
            x is in the current search space.\newline
            $\therefore$, x $\geq$ low.\newline
            $\therefore$, we have shown that the algorithm is correct.\newline
            Since the search space is doubled every time until x is in the search space or the
            search space exceeds the size of the array, then the algorithm is O($\log n$).\newline
            The second while loop is a modified binary search, which is O($\log n$).\newline
            We are trying to find x $<$ max in E[low:high].\newline
            \textbf{Case 1:} mid $>$ $\mid$E$\mid$ $\to$ x is the lower half of
            the search space.\newline
            \textbf{Case 2:} x $<$ E[mid] $\to$ x is the lower half of
            the search space.\newline
            \textbf{Case 3:} x $>$ E[mid] $\to$ x is the upper half of
            the search space.\newline
            \textbf{Case 4:} x = E[mid] $\to$ return mid.\newline
            $\therefore$, since the array is increasing, then if the element at mid is greater
            than x, we can ignore all elements after it too, and conversely, if the element at
            mid is less than x, we can ignore all elements before it.\newline
            $\therefore$, we half the search space each iteration, thus the algorithm is O($\log
            n$).
        \end{proof}
    \end{homeworkProblem}


    \begin{homeworkProblem}
        Your task is to do the following:
        \begin{enumerate}
            \item[i] \textbf{(7 points)}
            \begin{verbatim}
Initialize all TAs to be unassigned
Store all TA preferences in a sorted list for each course and the
number of TAs needed
while (course needs TA) {
    c = a course that needs a TA
    ta = first TA in c's preference list that c hasn't tried to assign
    if (ta is unqualified for c) {
        c rejects ta
    } else if (ta is unassigned) {
        assign ta to c
    } else if (ta prefers c to ta's current course) {
        c' = ta's current course
        unassign ta from c'
        assign ta to c
    }
    else {
        ta rejects c
    }
}
            \end{verbatim}
            \item[ii] \textbf{(7 points)}
            \begin{proof}
                The sorted list of applicants TAs for each course is strictly decreasing each
                iteration, $\therefore$ the algorithm will terminate.\newline
                Next, we show correctness.\newline
                Observation 1: Courses are assigned TAs in order of preference.\newline
                Observation 2: Once a TA is assigned to a course, they will not be unassigned,
                only reassigned to a different course.\newline
                Claim 1: All available TA spots are filled unless unqualified.\newline
                Proof: Assume by contradiction that there is an available TA spot upon termination,
                in other words, there is a course c$_0$ that needs a TA and there is one that's
                qualified and unassigned.\newline
                Since there are more TAs than courses, there must be a TA t$_0$ that is unassigned
                .\newline
                Since t$_0$ is unassigned, then c$_0$ must have rejected t$_0$, however, since t$
                _0$ is unassigned, then t$_0$ must be unqualified for c$_0$.\newline
                $\therefore$ we have a contradiction, and all available TA spots are filled
                unless unqualified.\newline
                Claim 2: All TAs are assigned to a course in a stable marriage.\newline
                Proof: Assume by contradiction that there is a TA t$_0$ that is assigned to
                course c$_1$ and TA t$_1$ that is assigned to course c$_0$ such that c$_0$
                prefers t$_0$ over t$_1$ and t$_0$ prefers c$_0$ over c$_1$.\newline
                Case 1: t$_0$ was never assigned to c$_0$.\newline
                Since c$_0$ prefers t$_0$ over t$_1$ and c$_0$ is assigned TAs based on preference,
                then t$_0$ must have been assigned to a course that is higher on t$_0$\'s
                preference list than c$_0$, which is a contradiction.\newline
                Case 2: t$_0$ was assigned to c$_0$ and then reassigned.\newline
                This means that t$_0$ rejected c$_0$ and was assigned to a course that is higher
                on their preference list than c$_0$.\newline
                However, since c$_1$ is lower on t$_0$\'s preference list than c$_0$, this is a
                contradiction.\newline
                $\therefore$, we have shown that all TAs are assigned to a course in a stable
                marriage.\newline
                $\therefore$, we have shown that the algorithm is totally correct.\newline
            \end{proof}
        \end{enumerate}
    \end{homeworkProblem}
\end{document}

 